package recap

import (
	"fmt"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/samber/lo"
	"go.uber.org/zap"

	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/types/bot/handlers/recap"
	"github.com/nekomeowww/insights-bot/pkg/types/telegram"
	"github.com/nekomeowww/insights-bot/pkg/types/tgchat"
)

func (h *CallbackQueryHandler) handleCallbackQuerySelectHours(c *tgbot.Context) (tgbot.Response, error) {
	messageID := c.Update.CallbackQuery.Message.MessageID

	replyToMessage := c.Update.CallbackQuery.Message.ReplyToMessage

	var data recap.SelectHourCallbackQueryData

	err := c.BindFromCallbackQueryData(&data)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).
			WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}
	if !lo.Contains(RecapSelectHourAvailable, data.Hour) {
		return nil, tgbot.
			NewExceptionError(fmt.Errorf("invalid hour: %d", data.Hour)).
			WithReply(replyToMessage)
	}

	var inProgressText string

	switch data.RecapMode {
	case tgchat.AutoRecapSendModePublicly:
		inProgressText = fmt.Sprintf("æ­£åœ¨ä¸ºè¿‡å» %d ä¸ªå°æ—¶çš„èŠå¤©è®°å½•ç”Ÿæˆå›é¡¾ï¼Œè¯·ç¨ç­‰...", data.Hour)
	case tgchat.AutoRecapSendModeOnlyPrivateSubscriptions:
		inProgressText = fmt.Sprintf("æ­£åœ¨ä¸º <b>%s</b> è¿‡å» %d ä¸ªå°æ—¶çš„èŠå¤©è®°å½•ç”Ÿæˆå›é¡¾ï¼Œè¯·ç¨ç­‰...", tgbot.EscapeHTMLSymbols(data.ChatTitle), data.Hour)
	default:
		inProgressText = fmt.Sprintf("æ­£åœ¨ä¸ºè¿‡å» %d ä¸ªå°æ—¶çš„èŠå¤©è®°å½•ç”Ÿæˆå›é¡¾ï¼Œè¯·ç¨ç­‰...", data.Hour)
	}

	editConfig := tgbotapi.NewEditMessageTextAndMarkup(
		c.Update.CallbackQuery.Message.Chat.ID,
		messageID,
		inProgressText,
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	)

	editConfig.ParseMode = tgbotapi.ModeHTML

	_, err = c.Bot.Request(editConfig)
	if err != nil {
		h.logger.Error("failed to edit message", zap.Error(err))
	}

	histories, err := h.chatHistories.FindChatHistoriesByTimeBefore(data.ChatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}
	if len(histories) <= 5 {
		var errMessage string

		switch data.RecapMode {
		case tgchat.AutoRecapSendModePublicly:
			errMessage = fmt.Sprintf("æœ€è¿‘ %d å°æ—¶å†…æš‚æ—¶æ²¡æœ‰è¶…è¿‡ 5 æ¡çš„èŠå¤©è®°å½•å¯ä»¥ç”ŸæˆèŠå¤©å›é¡¾å“¦ï¼Œè¦å†å¤šèŠç‚¹ä¹‹åå†è¯•è¯•å—ï¼Ÿ", data.Hour)
		case tgchat.AutoRecapSendModeOnlyPrivateSubscriptions:
			errMessage = fmt.Sprintf("æœ€è¿‘ %d å°æ—¶å†…æš‚æ—¶æ²¡æœ‰è¶…è¿‡ 5 æ¡çš„èŠå¤©è®°å½•å¯ä»¥ç”ŸæˆèŠå¤©å›é¡¾å“¦ï¼Œè¦å†ç­‰å¾…ç¾¤å†…æˆå‘˜å¤šèŠç‚¹ä¹‹åå†è¯•è¯•å—ï¼Ÿ", data.Hour)
		default:
			errMessage = fmt.Sprintf("æœ€è¿‘ %d å°æ—¶å†…æš‚æ—¶æ²¡æœ‰è¶…è¿‡ 5 æ¡çš„èŠå¤©è®°å½•å¯ä»¥ç”ŸæˆèŠå¤©å›é¡¾å“¦ï¼Œè¦å†å¤šèŠç‚¹ä¹‹åå†è¯•è¯•å—ï¼Ÿ", data.Hour)
		}

		return nil, tgbot.
			NewMessageError(errMessage).
			WithReply(replyToMessage)
	}

	chatType := telegram.ChatType(c.Update.CallbackQuery.Message.Chat.Type)

	logID, summarizations, err := h.chatHistories.SummarizeChatHistories(data.ChatID, chatType, histories)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}

	counts, err := h.chatHistories.FindFeedbackRecapsReactionCountsForChatIDAndLogID(data.ChatID, logID)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}

	inlineKeyboardMarkup, err := h.chatHistories.NewVoteRecapInlineKeyboardMarkup(c.Bot, data.ChatID, logID, counts.UpVotes, counts.DownVotes, counts.Lmao)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}

	summarizations = lo.Filter(summarizations, func(item string, _ int) bool { return item != "" })
	if len(summarizations) == 0 {
		return nil, tgbot.
			NewMessageError("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").
			WithReply(replyToMessage)
	}

	for i, s := range summarizations {
		summarizations[i] = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(s)
	}

	summarizationBatches := tgbot.SplitMessagesAgainstLengthLimitIntoMessageGroups(summarizations)
	for i, s := range summarizationBatches {
		var content string
		if len(summarizationBatches) > 1 {
			content = fmt.Sprintf("%s\n\n(%d/%d)\n%s#recap\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>",
				strings.Join(s, "\n\n"),
				i+1,
				len(summarizationBatches),
				lo.Ternary(chatType == telegram.ChatTypeGroup, "\n<b>Tips: </b>ç”±äºç¾¤ç»„ä¸æ˜¯è¶…çº§ç¾¤ç»„ï¼ˆsupergroupï¼‰ï¼Œå› æ­¤æ¶ˆæ¯é“¾æ¥å¼•ç”¨æš‚æ—¶è¢«ç¦ç”¨äº†ï¼Œå¦‚æœå¸Œæœ›ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œè¯·é€šè¿‡çŸ­æ—¶é—´å†…å°†ç¾¤ç»„å¼€æ”¾ä¸ºå…¬å…±ç¾¤ç»„å¹¶è¿˜åŸå›ç§æœ‰ç¾¤ç»„ï¼Œæˆ–é€šè¿‡å…¶ä»–æ“ä½œå°†æœ¬ç¾¤ç»„å‡çº§ä¸ºè¶…çº§ç¾¤ç»„åï¼Œè¯¥åŠŸèƒ½æ–¹å¯æ¢å¤æ­£å¸¸è¿ä½œã€‚\n\n", ""),
			)
		} else {
			content = fmt.Sprintf("%s\n\n%s#recap\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>",
				strings.Join(s, "\n\n"),
				lo.Ternary(chatType == telegram.ChatTypeGroup, "<b>Tips: </b>ç”±äºç¾¤ç»„ä¸æ˜¯è¶…çº§ç¾¤ç»„ï¼ˆsupergroupï¼‰ï¼Œå› æ­¤æ¶ˆæ¯é“¾æ¥å¼•ç”¨æš‚æ—¶è¢«ç¦ç”¨äº†ï¼Œå¦‚æœå¸Œæœ›ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œè¯·é€šè¿‡çŸ­æ—¶é—´å†…å°†ç¾¤ç»„å¼€æ”¾ä¸ºå…¬å…±ç¾¤ç»„å¹¶è¿˜åŸå›ç§æœ‰ç¾¤ç»„ï¼Œæˆ–é€šè¿‡å…¶ä»–æ“ä½œå°†æœ¬ç¾¤ç»„å‡çº§ä¸ºè¶…çº§ç¾¤ç»„åï¼Œè¯¥åŠŸèƒ½æ–¹å¯æ¢å¤æ­£å¸¸è¿ä½œã€‚\n\n", ""),
			)
		}

		msg := tgbotapi.NewMessage(c.Update.CallbackQuery.Message.Chat.ID, content)
		msg.ParseMode = tgbotapi.ModeHTML
		msg.ReplyMarkup = inlineKeyboardMarkup

		if c.Update.CallbackQuery.Message.ReplyToMessage != nil {
			msg.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		}

		h.logger.Info("sending chat histories recap for chat",
			zap.Int64("chat_id", c.Update.CallbackQuery.Message.Chat.ID),
			zap.String("text", msg.Text),
		)

		c.Bot.MaySend(msg)
	}

	return nil, nil
}
