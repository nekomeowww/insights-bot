package chat_history_recap

import (
	"context"
	"fmt"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	cron "github.com/robfig/cron/v3"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/bots/telegram"
	"github.com/nekomeowww/insights-bot/internal/models/chat_histories"
	"github.com/nekomeowww/insights-bot/internal/models/tgchats"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/logger"
	"github.com/nekomeowww/insights-bot/pkg/openai"
)

type NewChatHistoryRecapServiceParam struct {
	fx.In

	Lifecycle fx.Lifecycle

	Bot           *telegram.Bot
	Logger        *logger.Logger
	ChatHistories *chat_histories.Model
	TgChats       *tgchats.Model
	OpenAI        *openai.Client
}

type ChatHistoryRecapService struct {
	Cron *cron.Cron

	bot           *telegram.Bot
	logger        *logger.Logger
	chatHistories *chat_histories.Model
	tgchats       *tgchats.Model
	openai        *openai.Client
}

func NewChatHistoryRecapService() func(NewChatHistoryRecapServiceParam) (*ChatHistoryRecapService, error) {
	return func(param NewChatHistoryRecapServiceParam) (*ChatHistoryRecapService, error) {
		service := &ChatHistoryRecapService{
			Cron:          cron.New(),
			bot:           param.Bot,
			logger:        param.Logger,
			chatHistories: param.ChatHistories,
			tgchats:       param.TgChats,
			openai:        param.OpenAI,
		}

		_, err := service.Cron.AddFunc("@every 6h", service.SendChatHistoriesRecap)
		if err != nil {
			return nil, err
		}

		param.Lifecycle.Append(fx.Hook{
			OnStop: func(context.Context) error {
				service.Cron.Stop()
				return nil
			},
		})

		service.logger.Infof("chat history recap service started")
		return service, nil
	}
}

func Run() func(service *ChatHistoryRecapService) {
	return func(service *ChatHistoryRecapService) {
		service.Cron.Start()
	}
}

func (s *ChatHistoryRecapService) SendChatHistoriesRecap() {
	chatIDs, err := s.tgchats.ListChatHistoriesRecapEnabledChats()
	if err != nil {
		s.logger.Errorf("failed to list chat histories recap enabled chats: %v", err)
		return
	}

	for _, chatID := range chatIDs {
		s.logger.Infof("generating chat histories recap for chat %d", chatID)

		histories, err := s.chatHistories.FindLastSixHourChatHistories(chatID)
		if err != nil {
			s.logger.Errorf("failed to find last six hour chat histories: %v", err)
			continue
		}
		if len(histories) <= 5 {
			s.logger.Warn("no enough chat histories")
			continue
		}

		summarization, err := s.chatHistories.SummarizeChatHistories(chatID, histories)
		if err != nil {
			s.logger.Errorf("failed to summarize last six hour chat histories: %v", err)
			continue
		}
		if summarization == "" {
			s.logger.Warn("summarization is empty")
			continue
		}

		summarization, err = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(summarization)
		if err != nil {
			s.logger.Errorf("failed to replace markdown titles to telegram bold element: %v", err)
			continue
		}

		s.logger.Infof("sending chat histories recap for chat %d", chatID)
		message := tgbotapi.NewMessage(chatID, fmt.Sprintf("%s\n\n#recap #recap_auto\n<em>ü§ñÔ∏è Generated by chatGPT</em>", summarization))
		message.ParseMode = "HTML"
		_, err = s.bot.Send(message)
		if err != nil {
			s.logger.Errorf("failed to send chat histories recap: %v", err)
			continue
		}
	}
}
