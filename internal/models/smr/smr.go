package smr

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/url"
	"strings"

	"github.com/go-shiori/go-readability"
	"github.com/imroc/req/v3"
	"github.com/samber/lo"
	goopenai "github.com/sashabaranov/go-openai"
	"github.com/sirupsen/logrus"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/datastore"
	"github.com/nekomeowww/insights-bot/pkg/logger"
	"github.com/nekomeowww/insights-bot/pkg/openai"
)

type FromPlatform int

const (
	FromPlatformTelegram FromPlatform = iota
	FromPlatformSlack
	FromPlatformDiscord
)

type NewModelParams struct {
	fx.In

	OpenAIClient openai.Client
	Logger       *logger.Logger
	Ent          *datastore.Ent
}

type Model struct {
	openai openai.Client
	logger *logger.Logger
	req    *req.Client
	ent    *datastore.Ent
}

func NewModel() func(NewModelParams) *Model {
	return func(param NewModelParams) *Model {
		return &Model{
			req: req.
				C().
				SetUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.54"),
			logger: param.Logger,
			openai: param.OpenAIClient,
			ent:    param.Ent,
		}
	}
}

var (
	ErrNetworkError        = errors.New("network error")
	ErrRequestFailed       = errors.New("request failed")
	ErrContentNotSupported = errors.New("content not supported")
)

type URLSummarizationOutput struct {
	URL   string
	Title string
	Msg   string
}

func (u *URLSummarizationOutput) FormatSummarizationAsHTML() string {
	return fmt.Sprintf("<b><a href=\"%s\">%s</a></b>\n%s\n\n<em>ü§ñÔ∏è Generated by chatGPT</em>", u.URL, u.Title, u.Msg)
}

// FormatSummarizationAsSlackMarkdown the link syntax in slack markdown flavor is different than standard.
func (u *URLSummarizationOutput) FormatSummarizationAsSlackMarkdown() string {
	return fmt.Sprintf("*<%s|%s>*\n%s\n\n_ü§ñÔ∏è Generated by chatGPT_", u.URL, u.Title, u.Msg)
}

// FormatSummarizationAsDiscordMarkdown the link syntax is not support for all servers currently.
func (u *URLSummarizationOutput) FormatSummarizationAsDiscordMarkdown() string {
	return fmt.Sprintf("> %s\n**%s**\n%s\n\n_ü§ñÔ∏è Generated by chatGPT_", u.URL, u.Title, u.Msg)
}

func (m *Model) SummarizeInputURL(ctx context.Context, url string, fromPlatform FromPlatform) (*URLSummarizationOutput, error) {
	article, err := m.extractContentFromURL(ctx, url)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s, %w", url, err)
	}

	textContent := m.openai.TruncateContentBasedOnTokens(article.TextContent, 3000)

	m.logger.WithFields(logrus.Fields{
		"title": article.Title,
		"url":   url,
	}).Infof("‚úçÔ∏è summarizing article...")

	resp, err := m.openai.SummarizeWithQuestionsAsSimplifiedChinese(
		ctx,
		article.Title,
		article.Byline,
		textContent,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create chat completion for summarizing... %w", err)
	}

	respMessages := lo.Map(resp.Choices, func(item goopenai.ChatCompletionChoice, _ int) string {
		return item.Message.Content
	})
	if len(respMessages) == 0 {
		return nil, fmt.Errorf("no response from OpenAI")
	}

	m.logger.WithFields(logrus.Fields{
		"title":                  article.Title,
		"url":                    url,
		"prompt_token_usage":     resp.Usage.PromptTokens,
		"completion_token_usage": resp.Usage.CompletionTokens,
		"total_token_usage":      resp.Usage.TotalTokens,
	}).Infof("‚úÖ summarizing article done")

	err = m.ent.LogSummarizations.
		Create().
		SetContentURL(url).
		SetContentTitle(article.Title).
		SetContentAuthor(article.Byline).
		SetContentText(textContent).
		SetContentSummarizedOutputs(respMessages[0]).
		SetFromPlatform(int(fromPlatform)).
		Exec(context.Background())
	if err != nil {
		m.logger.WithError(err).Error("failed to create log")
		return nil, err
	}

	return &URLSummarizationOutput{
		URL:   url,
		Title: article.Title,
		Msg:   respMessages[0],
	}, nil
}

func (m *Model) extractContentFromURL(ctx context.Context, urlString string) (*readability.Article, error) {
	parsedURL, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}
	if parsedURL == nil {
		return nil, errors.New("empty url")
	}

	resp, err := m.req.
		R().
		EnableDump().
		SetContext(ctx).
		Get(parsedURL.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get url %s, %w: %v", parsedURL.String(), ErrNetworkError, err)
	}
	if !resp.IsSuccessState() {
		return nil, fmt.Errorf("failed to get url %s, %w, status code: %d, dump: %s", parsedURL.String(), ErrRequestFailed, resp.StatusCode, resp.Dump())
	}
	if !strings.Contains(resp.Header.Get("Content-Type"), "text/html") {
		return nil, fmt.Errorf("url fetched, but content-type not supported yet, %w, content-type: %s", ErrContentNotSupported, resp.Header.Get("Content-Type"))
	}

	defer resp.Body.Close()
	buffer := new(bytes.Buffer)

	_, err = io.Copy(buffer, resp.Body)
	if err != nil {
		return nil, err
	}

	urlContent, err := readability.FromReader(buffer, parsedURL)
	if err != nil {
		return nil, err
	}

	return &urlContent, nil
}
