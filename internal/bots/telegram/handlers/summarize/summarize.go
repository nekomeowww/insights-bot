package summarize

import (
	"bytes"
	"fmt"
	"math"
	"net/url"
	"strings"
	"time"

	"github.com/go-shiori/go-readability"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/imroc/req/v3"
	tokenizer "github.com/pandodao/tokenizer-go"
	"github.com/samber/lo"
	goopenai "github.com/sashabaranov/go-openai"
	"github.com/sirupsen/logrus"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/pkg/handler"
	"github.com/nekomeowww/insights-bot/pkg/logger"
	"github.com/nekomeowww/insights-bot/pkg/openai"
)

type NewHandlerParam struct {
	fx.In

	Logger *logger.Logger
	OpenAI *openai.Client
}

type Handler struct {
	Logger *logger.Logger

	ReqClient *req.Client
	OpenAI    *openai.Client
}

func NewHandler() func(param NewHandlerParam) *Handler {
	return func(param NewHandlerParam) *Handler {
		handler := &Handler{
			Logger:    param.Logger,
			ReqClient: req.C(),
			OpenAI:    param.OpenAI,
		}
		return handler
	}
}

func (h *Handler) HandleChannelPost(c *handler.Context) {
	// è½¬å‘çš„æ¶ˆæ¯ä¸å¤„ç†
	if c.Update.ChannelPost.ForwardFrom != nil {
		return
	}
	// è½¬å‘çš„æ¶ˆæ¯ä¸å¤„ç†
	if c.Update.ChannelPost.ForwardFromChat != nil {
		return
	}
	// è‹¥æ—  /s å‘½ä»¤åˆ™ä¸å¤„ç†
	if !strings.HasPrefix(c.Update.ChannelPost.Text, "/smr ") {
		return
	}

	c.Update.ChannelPost.Text = strings.TrimPrefix(c.Update.ChannelPost.Text, "/smr ")
	article, err := extractContentFromURL(c.Update.ChannelPost.Text)
	if err != nil {
		h.Logger.Errorf("failed to parse %s, %v\n", c.Update.ChannelPost.Text, err)
		return
	}

	textContent, err := truncateContentBasedOnTokens(article.TextContent)
	if err != nil {
		h.Logger.Errorf("failed to truncate content based on tokens... %v", err)
		return
	}

	h.Logger.WithFields(logrus.Fields{
		"title": article.Title,
		"url":   c.Update.ChannelPost.Text,
	}).Infof("âœï¸ summarizing article...")
	resp, err := h.OpenAI.SummarizeWithQuestionsAsSimplifiedChinese(
		article.Title,
		article.Byline,
		textContent,
	)
	if err != nil {
		h.Logger.Errorf("failed to create chat completion for summarizing... %v", err)
		return
	}

	h.Logger.WithFields(logrus.Fields{
		"title":                  article.Title,
		"url":                    c.Update.ChannelPost.Text,
		"prompt_token_usage":     resp.Usage.PromptTokens,
		"completion_token_usage": resp.Usage.CompletionTokens,
		"total_token_usage":      resp.Usage.TotalTokens,
	}).Infof("âœ… summarizing article done")
	respMessages := lo.Map(resp.Choices, func(item goopenai.ChatCompletionChoice, _ int) string {
		return item.Message.Content
	})

	_, err = c.Bot.Request(tgbotapi.EditMessageTextConfig{
		BaseEdit: tgbotapi.BaseEdit{
			ChatID:    c.Update.ChannelPost.Chat.ID,
			MessageID: c.Update.ChannelPost.MessageID,
		},
		ParseMode: "HTML", // è¿™ä¸ªç»“æ„ä½“é‡Œé¢éœ€è¦ç»™ ParseMode å­—æ®µèµ‹ä¸€ä¸ªå­—é¢é‡ä¸º HTML çš„æšä¸¾å€¼
		Text:      fmt.Sprintf("<b><a href=\"%s\">%s</a></b>\n%s\n\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>", c.Update.ChannelPost.Text, article.Title, strings.Join(respMessages, "\n")),
	})
	if err != nil {
		h.Logger.Errorf("failed to send message to telegram... %v", err)
		return
	}
}

func extractContentFromURL(urlString string) (*readability.Article, error) {
	parsedURL, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}

	buffer := new(bytes.Buffer)
	resp, err := req.
		C().
		SetUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.54").
		SetTimeout(time.Minute).
		R().
		SetOutput(buffer).
		Get(parsedURL.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get url %s, %v", parsedURL.String(), err)
	}
	if !resp.IsSuccess() {
		return nil, fmt.Errorf("failed to get url %s, status code: %d, dump: %s", parsedURL.String(), resp.StatusCode, resp.Dump())
	}

	urlContent, err := readability.FromReader(buffer, parsedURL)
	if err != nil {
		return nil, err
	}

	return &urlContent, nil
}

// truncateContentBasedOnTokens åŸºäº token è®¡ç®—çš„æ–¹å¼æˆªæ–­æ–‡æœ¬
func truncateContentBasedOnTokens(textContent string) (string, error) {
	tokens, err := tokenizer.CalToken(textContent)
	if err != nil {
		return "", err
	}
	if tokens > 3900 {
		return string([]rune(textContent)[:int(math.Min(3900, float64(len(textContent))))]), nil
	}

	return textContent, nil
}
