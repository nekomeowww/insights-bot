package autorecap

import (
	"context"
	"fmt"
	"strings"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/nekomeowww/timecapsule/v2"
	"github.com/samber/lo"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/datastore"
	"github.com/nekomeowww/insights-bot/internal/models/chathistories"
	"github.com/nekomeowww/insights-bot/internal/models/tgchats"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/logger"
	"github.com/nekomeowww/insights-bot/pkg/types/timecapsules"
)

type NewAutoRecapParams struct {
	fx.In

	Lifecycle fx.Lifecycle

	Logger        *logger.Logger
	Bot           *tgbot.BotService
	ChatHistories *chathistories.Model
	TgChats       *tgchats.Model
	Digger        *datastore.AutoRecapTimeCapsuleDigger
}

type AutoRecapService struct {
	logger        *logger.Logger
	bot           *tgbot.BotService
	chathistories *chathistories.Model
	tgchats       *tgchats.Model

	digger  *datastore.AutoRecapTimeCapsuleDigger
	started bool
}

func NewAutoRecapService() func(NewAutoRecapParams) (*AutoRecapService, error) {
	return func(params NewAutoRecapParams) (*AutoRecapService, error) {
		service := &AutoRecapService{
			logger:        params.Logger,
			bot:           params.Bot,
			chathistories: params.ChatHistories,
			tgchats:       params.TgChats,
			digger:        params.Digger,
		}

		service.digger.SetHandler(service.sendChatHistoriesRecap)
		service.tgchats.QueueSendChatHistoriesRecapTask()

		return service, nil
	}
}

func (s AutoRecapService) Check(ctx context.Context) error {
	return lo.Ternary(s.started, nil, fmt.Errorf("auto recap not started yet"))
}

func Run() func(service *AutoRecapService) {
	return func(service *AutoRecapService) {
		service.started = true
	}
}

func (m *AutoRecapService) sendChatHistoriesRecap(
	digger *timecapsule.TimeCapsuleDigger[timecapsules.AutoRecapCapsule],
	capsule *timecapsule.TimeCapsule[timecapsules.AutoRecapCapsule],
) {
	m.logger.Infof("generating chat histories recap for chat %d", capsule.Payload.ChatID)

	histories, err := m.chathistories.FindLastSixHourChatHistories(capsule.Payload.ChatID)
	if err != nil {
		m.logger.Errorf("failed to find last six hour chat histories: %v", err)
		return
	}
	if len(histories) <= 5 {
		m.logger.Warn("no enough chat histories")
		return
	}

	summarizations, err := m.chathistories.SummarizeChatHistories(capsule.Payload.ChatID, histories)
	if err != nil {
		m.logger.Errorf("failed to summarize last six hour chat histories: %v", err)
		return
	}

	summarizations = lo.Filter(summarizations, func(item string, _ int) bool { return item != "" })
	if len(summarizations) == 0 {
		m.logger.Warn("summarization is empty")
		return
	}

	for i, s := range summarizations {
		summarizations[i] = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(s)
	}

	summarizationBatches := tgbot.SplitMessagesAgainstLengthLimitIntoMessageGroups(summarizations)
	for i, b := range summarizationBatches {
		var content string
		if len(summarizationBatches) > 1 {
			content = fmt.Sprintf("%s\n\n(%d/%d)\n#recap #recap_auto\n<em>ü§ñÔ∏è Generated by chatGPT</em>", strings.Join(b, "\n\n"), i+1, len(summarizationBatches))
		} else {
			content = fmt.Sprintf("%s\n\n#recap #recap_auto\n<em>ü§ñÔ∏è Generated by chatGPT</em>", strings.Join(b, "\n\n"))
		}

		msg := tgbotapi.NewMessage(capsule.Payload.ChatID, content)
		msg.ParseMode = tgbotapi.ModeHTML

		m.logger.Infof("sending chat histories recap for chat %d: %s", capsule.Payload.ChatID, msg.Text)

		_, err = m.bot.Send(msg)
		if err != nil {
			m.logger.Errorf("failed to send chat histories recap: %v", err)
		}
	}
}
