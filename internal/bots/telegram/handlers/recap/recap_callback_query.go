package recap

import (
	"fmt"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/samber/lo"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/models/chathistories"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/logger"
)

var (
	_ tgbot.CallbackQueryHandler = (*CallbackQueryHandler)(nil)
)

type NewRecapCallbackQueryHandlerParams struct {
	fx.In

	Logger        *logger.Logger
	ChatHistories *chathistories.Model
}

type CallbackQueryHandler struct {
	logger        *logger.Logger
	chatHistories *chathistories.Model
}

func NewRecapCallbackQueryHandler() func(NewRecapCallbackQueryHandlerParams) *CallbackQueryHandler {
	return func(param NewRecapCallbackQueryHandlerParams) *CallbackQueryHandler {
		return &CallbackQueryHandler{
			logger:        param.Logger,
			chatHistories: param.ChatHistories,
		}
	}
}

type SelectHourCallbackQueryData struct {
	Hour int64 `schema:"hour" json:"hour"`
}

func (h CallbackQueryHandler) CallbackQueryRoute() string {
	return "recap/select_hour"
}

func (h *CallbackQueryHandler) Handle(c *tgbot.Context) (tgbot.Response, error) {
	chatID := c.Update.CallbackQuery.Message.Chat.ID
	messageID := c.Update.CallbackQuery.Message.MessageID

	var data SelectHourCallbackQueryData

	err := c.CallbackQueryDataBindQuery(&data)
	if err != nil {
		return nil, tgbot.NewExceptionError(err)
	}
	if !lo.Contains(RecapSelectHourAvailable, data.Hour) {
		return nil, tgbot.NewExceptionError(fmt.Errorf("invalid hour: %d", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	_, err = c.Bot.Request(tgbotapi.NewEditMessageTextAndMarkup(
		chatID,
		messageID,
		fmt.Sprintf("æ­£åœ¨ä¸ºè¿‡å» %d ä¸ªå°æ—¶çš„èŠå¤©è®°å½•ç”Ÿæˆå›é¡¾ï¼Œè¯·ç¨ç­‰...", data.Hour),
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	))
	if err != nil {
		h.logger.Errorf("failed to delete message: %v", err)
	}

	histories, err := h.chatHistories.FindChatHistoriesByTimeBefore(chatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}
	if len(histories) <= 5 {
		fmt.Println(len(histories))
		return nil, tgbot.NewMessageError(fmt.Sprintf("æœ€è¿‘ %d å°æ—¶å†…æš‚æ—¶æ²¡æœ‰è¶…è¿‡ 5 æ¡çš„èŠå¤©è®°å½•å¯ä»¥ç”ŸæˆèŠå¤©å›é¡¾å“¦ï¼Œè¦å†å¤šèŠç‚¹ä¹‹åå†è¯•è¯•å—ï¼Ÿ", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarizations, err := h.chatHistories.SummarizeChatHistories(chatID, histories)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarizations = lo.Filter(summarizations, func(item string, _ int) bool { return item != "" })
	if len(summarizations) == 0 {
		return nil, tgbot.NewMessageError("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	for i, s := range summarizations {
		summarizations[i] = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(s)
	}

	summarizationBatches := tgbot.SplitMessagesAgainstLengthLimitIntoMessageGroups(summarizations)
	for i, s := range summarizationBatches {
		var content string
		if len(summarizationBatches) > 1 {
			content = fmt.Sprintf("%s\n\n(%d/%d)\n#recap\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>", strings.Join(s, "\n\n"), i+1, len(summarizationBatches))
		} else {
			content = fmt.Sprintf("%s\n\n#recap\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>", strings.Join(s, "\n\n"))
		}

		msg := tgbotapi.NewMessage(chatID, content)
		msg.ParseMode = tgbotapi.ModeHTML
		msg.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID

		h.logger.Infof("sending chat histories recap for chat %d: %s", chatID, msg.Text)

		c.Bot.MustSend(msg)
	}

	return nil, nil
}
