package chat_with_chat_history

import (
	"fmt"
	"net/url"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	telegram_bot "github.com/nekomeowww/insights-bot/pkg/bots/telegram"
	"github.com/nekomeowww/insights-bot/pkg/handler"
	"github.com/samber/lo"
)

var (
	RecapSelectHourAvailables = []int64{
		1, 2, 4, 6, 12,
	}
	RecapSelectHourAvailableText = lo.SliceToMap(RecapSelectHourAvailables, func(item int64) (int64, string) {
		return item, fmt.Sprintf("%d 小时", item)
	})
	RecapSelectHourAvailableValues = lo.SliceToMap(RecapSelectHourAvailables, func(item int64) (int64, string) {
		return item, fmt.Sprintf("%d", item)
	})
)

func (h *Handler) HandleRecapCommand(c *handler.Context) {
	chatID := c.Update.Message.Chat.ID
	h.Logger.Infof("generating chat histories recap for chat %d", chatID)

	message := tgbotapi.NewMessage(chatID, "要创建过去几个小时内的聊天回顾呢？")
	message.ReplyToMessageID = c.Update.Message.MessageID
	message.ReplyMarkup = tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			lo.Map(RecapSelectHourAvailables, func(item int64, _ int) tgbotapi.InlineKeyboardButton {
				return tgbotapi.NewInlineKeyboardButtonData(
					RecapSelectHourAvailableText[item],
					telegram_bot.NewCallbackQueryData("recap", "select_hour", url.Values{"hour": []string{RecapSelectHourAvailableValues[item]}}),
				)
			})...,
		),
	)

	c.Bot.MustSend(message)
}

type RecapSelectHourCallbackQueryData struct {
	Hour int64 `schema:"hour" json:"hour"`
}

func (h *Handler) HandleCallbackQuery(c *handler.Context) {
	chatID := c.Update.CallbackQuery.Message.Chat.ID
	messageID := c.Update.CallbackQuery.Message.MessageID

	var data RecapSelectHourCallbackQueryData
	err := c.CallbackQueryDataBindQuery(&data)
	if err != nil {
		h.Logger.Errorf("failed to bind callback query data: %v", err)
		return
	}
	if !lo.Contains(RecapSelectHourAvailables, data.Hour) {
		h.Logger.Errorf("invalid hour: %v", data.Hour)

		errMessage := tgbotapi.NewMessage(chatID, "出现了一些问题，请稍后再试哦")
		errMessage.ReplyToMessageID = c.Update.CallbackQuery.Message.MessageID
		c.Bot.MustSend(errMessage)
	}

	_, err = c.Bot.Request(tgbotapi.NewEditMessageTextAndMarkup(
		chatID,
		messageID,
		fmt.Sprintf("正在为过去 %d 个小时的聊天记录生成回顾，请稍等...", data.Hour),
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	))
	if err != nil {
		h.Logger.Errorf("failed to delete message: %v", err)
	}

	histories, err := h.ChatHistories.FindChatHistoriesByTimeBefore(chatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		h.Logger.Errorf("failed to find last one hour chat histories: %v", err)

		errMessage := tgbotapi.NewMessage(chatID, "聊天记录回顾生成失败，请稍后再试！")
		errMessage.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		c.Bot.MustSend(errMessage)
		return
	}
	if len(histories) <= 5 {
		h.Logger.Warn("chat histories are too few")

		errMessage := tgbotapi.NewMessage(chatID, fmt.Sprintf("最近 %d 小时内暂时没有超过 5 条的聊天记录可以生成聊天回顾哦，要再多聊点之后再试试吗？", data.Hour))
		errMessage.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		c.Bot.MustSend(errMessage)
		return
	}

	summarization, err := h.ChatHistories.SummarizeChatHistories(histories)
	if err != nil {
		h.Logger.Errorf("failed to summarize last one hour chat histories: %v", err)

		errMessage := tgbotapi.NewMessage(chatID, "聊天记录回顾生成失败，请稍后再试！")
		errMessage.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		c.Bot.MustSend(errMessage)
		return
	}
	if summarization == "" {
		h.Logger.Warn("summarization is empty")

		errMessage := tgbotapi.NewMessage(chatID, "聊天记录回顾生成失败，请稍后再试！")
		errMessage.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		c.Bot.MustSend(errMessage)
		return
	}

	h.Logger.Infof("sending chat histories recap for chat %d", chatID)
	message := tgbotapi.NewMessage(chatID, fmt.Sprintf("%s\n\n#recap\n<em>🤖️ Generated by chatGPT</em>", summarization))
	message.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
	message.ParseMode = "HTML"
	c.Bot.MustSend(message)
}
