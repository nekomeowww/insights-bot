package recap

import (
	"fmt"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/samber/lo"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/models/chat_histories"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/logger"
)

var (
	_ tgbot.CallbackQueryHandler = (*RecapCallbackQueryHandler)(nil)
)

type NewRecapCallbackQueryHandlerParams struct {
	fx.In

	Logger        *logger.Logger
	ChatHistories *chat_histories.Model
}

type RecapCallbackQueryHandler struct {
	logger        *logger.Logger
	chatHistories *chat_histories.Model
}

func NewRecapCallbackQueryHandler() func(NewRecapCallbackQueryHandlerParams) *RecapCallbackQueryHandler {
	return func(param NewRecapCallbackQueryHandlerParams) *RecapCallbackQueryHandler {
		return &RecapCallbackQueryHandler{
			logger:        param.Logger,
			chatHistories: param.ChatHistories,
		}
	}
}

type RecapSelectHourCallbackQueryData struct {
	Hour int64 `schema:"hour" json:"hour"`
}

func (h RecapCallbackQueryHandler) CallbackQueryRoute() string {
	return "recap/select_hour"
}

func (h *RecapCallbackQueryHandler) Handle(c *tgbot.Context) (tgbot.Response, error) {
	chatID := c.Update.CallbackQuery.Message.Chat.ID
	messageID := c.Update.CallbackQuery.Message.MessageID

	var data RecapSelectHourCallbackQueryData
	err := c.CallbackQueryDataBindQuery(&data)
	if err != nil {
		return nil, tgbot.NewExceptionError(err)
	}
	if !lo.Contains(RecapSelectHourAvailables, data.Hour) {
		return nil, tgbot.NewExceptionError(fmt.Errorf("invalid hour: %d", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	_, err = c.Bot.Request(tgbotapi.NewEditMessageTextAndMarkup(
		chatID,
		messageID,
		fmt.Sprintf("æ­£åœ¨ä¸ºè¿‡å» %d ä¸ªå°æ—¶çš„èŠå¤©è®°å½•ç”Ÿæˆå›é¡¾ï¼Œè¯·ç¨ç­‰...", data.Hour),
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	))
	if err != nil {
		h.logger.Errorf("failed to delete message: %v", err)
	}

	histories, err := h.chatHistories.FindChatHistoriesByTimeBefore(chatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}
	if len(histories) <= 5 {
		fmt.Println(len(histories))
		return nil, tgbot.NewMessageError(fmt.Sprintf("æœ€è¿‘ %d å°æ—¶å†…æš‚æ—¶æ²¡æœ‰è¶…è¿‡ 5 æ¡çš„èŠå¤©è®°å½•å¯ä»¥ç”ŸæˆèŠå¤©å›é¡¾å“¦ï¼Œè¦å†å¤šèŠç‚¹ä¹‹åå†è¯•è¯•å—ï¼Ÿ", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarization, err := h.chatHistories.SummarizeChatHistories(chatID, histories)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}
	if summarization == "" {
		return nil, tgbot.NewMessageError("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarization, err = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(summarization)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("èŠå¤©è®°å½•å›é¡¾ç”Ÿæˆå¤±è´¥ï¼Œè¯·ç¨åå†è¯•ï¼").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	h.logger.Infof("sending chat histories recap for chat %d: %s", chatID, summarization)
	return c.NewMessageReplyTo(fmt.Sprintf("%s\n\n#recap\n<em>ğŸ¤–ï¸ Generated by chatGPT</em>", summarization), c.Update.CallbackQuery.Message.ReplyToMessage.MessageID).WithParseModeHTML(), nil
}
