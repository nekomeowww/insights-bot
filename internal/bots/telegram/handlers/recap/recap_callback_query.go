package recap

import (
	"fmt"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/samber/lo"
	"go.uber.org/fx"

	"github.com/nekomeowww/insights-bot/internal/models/chat_histories"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/logger"
)

var (
	_ tgbot.CallbackQueryHandler = (*RecapCallbackQueryHandler)(nil)
)

type NewRecapCallbackQueryHandlerParams struct {
	fx.In

	Logger        *logger.Logger
	ChatHistories *chat_histories.Model
}

type RecapCallbackQueryHandler struct {
	logger        *logger.Logger
	chatHistories *chat_histories.Model
}

func NewRecapCallbackQueryHandler() func(NewRecapCallbackQueryHandlerParams) *RecapCallbackQueryHandler {
	return func(param NewRecapCallbackQueryHandlerParams) *RecapCallbackQueryHandler {
		return &RecapCallbackQueryHandler{
			logger:        param.Logger,
			chatHistories: param.ChatHistories,
		}
	}
}

type RecapSelectHourCallbackQueryData struct {
	Hour int64 `schema:"hour" json:"hour"`
}

func (h RecapCallbackQueryHandler) CallbackQueryRoute() string {
	return "recap/select_hour"
}

func (h *RecapCallbackQueryHandler) Handle(c *tgbot.Context) (tgbot.Response, error) {
	chatID := c.Update.CallbackQuery.Message.Chat.ID
	messageID := c.Update.CallbackQuery.Message.MessageID

	var data RecapSelectHourCallbackQueryData
	err := c.CallbackQueryDataBindQuery(&data)
	if err != nil {
		return nil, tgbot.NewExceptionError(err)
	}
	if !lo.Contains(RecapSelectHourAvailables, data.Hour) {
		return nil, tgbot.NewExceptionError(fmt.Errorf("invalid hour: %d", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	_, err = c.Bot.Request(tgbotapi.NewEditMessageTextAndMarkup(
		chatID,
		messageID,
		fmt.Sprintf("正在为过去 %d 个小时的聊天记录生成回顾，请稍等...", data.Hour),
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	))
	if err != nil {
		h.logger.Errorf("failed to delete message: %v", err)
	}

	histories, err := h.chatHistories.FindChatHistoriesByTimeBefore(chatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}
	if len(histories) <= 5 {
		fmt.Println(len(histories))
		return nil, tgbot.NewMessageError(fmt.Sprintf("最近 %d 小时内暂时没有超过 5 条的聊天记录可以生成聊天回顾哦，要再多聊点之后再试试吗？", data.Hour)).WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarization, err := h.chatHistories.SummarizeChatHistories(chatID, histories)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}
	if summarization == "" {
		return nil, tgbot.NewMessageError("聊天记录回顾生成失败，请稍后再试！").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	summarization, err = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(summarization)
	if err != nil {
		return nil, tgbot.NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").WithReply(c.Update.CallbackQuery.Message.ReplyToMessage)
	}

	h.logger.Infof("sending chat histories recap for chat %d: %s", chatID, summarization)
	return c.NewMessageReplyTo(fmt.Sprintf("%s\n\n#recap\n<em>🤖️ Generated by chatGPT</em>", summarization), c.Update.CallbackQuery.Message.ReplyToMessage.MessageID).WithParseModeHTML(), nil
}
