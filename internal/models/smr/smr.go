package smr

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/imroc/req/v3"

	"github.com/go-shiori/go-readability"
	"github.com/samber/lo"
	goopenai "github.com/sashabaranov/go-openai"
	"go.uber.org/fx"
	"go.uber.org/zap"

	"github.com/nekomeowww/insights-bot/internal/configs"
	"github.com/nekomeowww/insights-bot/internal/datastore"
	"github.com/nekomeowww/insights-bot/internal/thirdparty/openai"
	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/linkprev"
	"github.com/nekomeowww/insights-bot/pkg/logger"
	"github.com/nekomeowww/insights-bot/pkg/types/bot"
	"github.com/nekomeowww/xo"
)

type NewModelParams struct {
	fx.In

	Config       *configs.Config
	OpenAIClient openai.Client
	Logger       *logger.Logger
	Ent          *datastore.Ent
}

type Model struct {
	config   *configs.Config
	openai   openai.Client
	logger   *logger.Logger
	req      *req.Client
	linkprev *linkprev.Client
	ent      *datastore.Ent
}

func NewModel() func(NewModelParams) *Model {
	return func(param NewModelParams) *Model {
		return &Model{
			config: param.Config,
			req: req.
				C().
				SetUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.54").
				EnableDumpEachRequest(),
			linkprev: linkprev.NewClient(),
			logger:   param.Logger,
			openai:   param.OpenAIClient,
			ent:      param.Ent,
		}
	}
}

var (
	ErrNetworkError        = errors.New("network error")
	ErrRequestFailed       = errors.New("request failed")
	ErrContentNotSupported = errors.New("content not supported")
)

type URLSummarizationOutput struct {
	ID    uuid.UUID
	URL   string
	Title string
	Msg   string
}

func (u *URLSummarizationOutput) FormatSummarizationAsHTML() string {
	return fmt.Sprintf("<b><a href=\"%s\">%s</a></b>\n%s\n\n<em>ü§ñÔ∏è Generated by chatGPT</em>", u.URL, tgbot.EscapeHTMLSymbols(u.Title), u.Msg)
}

// FormatSummarizationAsSlackMarkdown the link syntax in slack markdown flavor is different than standard.
func (u *URLSummarizationOutput) FormatSummarizationAsSlackMarkdown() string {
	return fmt.Sprintf("*<%s|%s>*\n%s\n\n_ü§ñÔ∏è Generated by chatGPT_", u.URL, u.Title, u.Msg)
}

// FormatSummarizationAsDiscordMarkdown the link syntax is not support for all servers currently.
func (u *URLSummarizationOutput) FormatSummarizationAsDiscordMarkdown() string {
	return fmt.Sprintf("> %s\n**%s**\n%s\n\n_ü§ñÔ∏è Generated by chatGPT_", u.URL, u.Title, u.Msg)
}

func (m *Model) SummarizeInputURL(ctx context.Context, url string, fromPlatform bot.FromPlatform) (*URLSummarizationOutput, error) {
	article, err := m.extractContentFromURL(ctx, url)
	if err != nil {
		return nil, fmt.Errorf("failed to parse %s, %w", url, err)
	}

	textContent := m.openai.TruncateContentBasedOnTokens(article.TextContent, int(m.config.OpenAI.TokenLimit)-1200)

	m.logger.Info("‚úçÔ∏è summarizing article...", zap.String("title", article.Title), zap.String("url", url))

	resp, err := m.openai.SummarizeWithQuestionsAsSimplifiedChinese(
		ctx,
		article.Title,
		article.Byline,
		textContent,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create chat completion for summarizing... %w", err)
	}

	respMessages := lo.Map(resp.Choices, func(item goopenai.ChatCompletionChoice, _ int) string {
		return item.Message.Content
	})
	if len(respMessages) == 0 {
		return nil, fmt.Errorf("no response from OpenAI")
	}

	m.logger.Info("‚úÖ summarizing article done", zap.String("title", article.Title), zap.String("url", url))

	saved, err := m.ent.LogSummarizations.
		Create().
		SetContentURL(url).
		SetContentTitle(article.Title).
		SetContentAuthor(article.Byline).
		SetContentText(textContent).
		SetContentSummarizedOutputs(respMessages[0]).
		SetFromPlatform(int(fromPlatform)).
		SetCompletionTokenUsage(resp.Usage.CompletionTokens).
		SetPromptTokenUsage(resp.Usage.PromptTokens).
		SetTotalTokenUsage(resp.Usage.TotalTokens).
		SetModelName(m.openai.GetModelName()).
		Save(context.Background())
	if err != nil {
		m.logger.Error("failed to create log", zap.Error(err))
		return nil, err
	}

	return &URLSummarizationOutput{
		ID:    saved.ID,
		URL:   url,
		Title: article.Title,
		Msg:   respMessages[0],
	}, nil
}

func (m *Model) extractContentFromURL(ctx context.Context, urlString string) (*readability.Article, error) {
	parsedURL, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}
	if parsedURL == nil {
		return nil, errors.New("empty url")
	}

	if lo.Contains([]string{"twitter.com", "vxtwitter.com", "fxtwitter.com"}, parsedURL.Host) {
		meta, err := m.linkprev.Preview(ctx, urlString)
		if err != nil {
			return nil, fmt.Errorf("failed to get url %s, %w: %v", parsedURL.String(), ErrNetworkError, err)
		}

		return &readability.Article{
			Title:       "Tweet",
			Byline:      meta.OpenGraph.Title,
			Content:     meta.OpenGraph.Description,
			TextContent: meta.OpenGraph.Description,
		}, nil
	}

	dumpBuffer := new(bytes.Buffer)
	defer func() {
		dumpBuffer.Reset()
		dumpBuffer = nil
	}()

	request := m.req.
		R().
		EnableDumpTo(dumpBuffer).
		DisableAutoReadResponse().
		SetContext(ctx)
	defer func() {
		request.EnableDumpTo(xo.NewNopIoWriter())
	}()

	resp, err := request.Get(parsedURL.String())
	if err != nil {
		return nil, fmt.Errorf("failed to get url %s, %w: %v", parsedURL.String(), ErrNetworkError, err)
	}
	if !resp.IsSuccessState() {
		errorBuf := new(bytes.Buffer)
		defer errorBuf.Reset()

		_, err = io.Copy(errorBuf, resp.Body)
		if err != nil {
			fmt.Fprintf(errorBuf, "failed to read response body: %v", err)
		}

		dumpBuffer.WriteString("\n")
		dumpBuffer.Write(errorBuf.Bytes())

		return nil, fmt.Errorf("failed to get url %s, %w, status code: %d, dump: %s", parsedURL.String(), ErrRequestFailed, resp.StatusCode, dumpBuffer.String())
	}
	if !strings.Contains(resp.Header.Get("Content-Type"), "text/html") {
		return nil, fmt.Errorf("url fetched, but content-type not supported yet, %w, content-type: %s", ErrContentNotSupported, resp.Header.Get("Content-Type"))
	}

	defer resp.Body.Close()

	buffer := new(bytes.Buffer)
	defer buffer.Reset()

	_, err = io.Copy(buffer, resp.Body)
	if err != nil {
		return nil, err
	}

	urlContent, err := readability.FromReader(buffer, parsedURL)
	if err != nil {
		return nil, err
	}

	return &urlContent, nil
}

func (m *Model) SummarizeWebpageRatePerSeconds() time.Duration {
	seconds := m.config.HardLimit.SummarizeWebpageRatePerSeconds
	return time.Duration(seconds) * time.Second
}
