package recap

import (
	"fmt"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/samber/lo"
	"go.uber.org/zap"

	"github.com/nekomeowww/insights-bot/pkg/bots/tgbot"
	"github.com/nekomeowww/insights-bot/pkg/types/bot/handlers/recap"
	"github.com/nekomeowww/insights-bot/pkg/types/telegram"
	"github.com/nekomeowww/insights-bot/pkg/types/tgchat"
)

func (h *CallbackQueryHandler) handleCallbackQuerySelectHours(c *tgbot.Context) (tgbot.Response, error) {
	messageID := c.Update.CallbackQuery.Message.MessageID

	replyToMessage := c.Update.CallbackQuery.Message.ReplyToMessage

	var data recap.SelectHourCallbackQueryData

	err := c.BindFromCallbackQueryData(&data)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).
			WithMessage("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}
	if !lo.Contains(RecapSelectHourAvailable, data.Hour) {
		return nil, tgbot.
			NewExceptionError(fmt.Errorf("invalid hour: %d", data.Hour)).
			WithReply(replyToMessage)
	}

	var inProgressText string

	switch data.RecapMode {
	case tgchat.AutoRecapSendModePublicly:
		inProgressText = fmt.Sprintf("正在为过去 %d 个小时的聊天记录生成回顾，请稍等...", data.Hour)
	case tgchat.AutoRecapSendModeOnlyPrivateSubscriptions:
		inProgressText = fmt.Sprintf("正在为 <b>%s</b> 过去 %d 个小时的聊天记录生成回顾，请稍等...", tgbot.EscapeHTMLSymbols(data.ChatTitle), data.Hour)
	default:
		inProgressText = fmt.Sprintf("正在为过去 %d 个小时的聊天记录生成回顾，请稍等...", data.Hour)
	}

	editConfig := tgbotapi.NewEditMessageTextAndMarkup(
		c.Update.CallbackQuery.Message.Chat.ID,
		messageID,
		inProgressText,
		tgbotapi.NewInlineKeyboardMarkup([]tgbotapi.InlineKeyboardButton{}),
	)

	editConfig.ParseMode = tgbotapi.ModeHTML

	_, err = c.Bot.Request(editConfig)
	if err != nil {
		h.logger.Error("failed to edit message", zap.Error(err))
	}

	histories, err := h.chatHistories.FindChatHistoriesByTimeBefore(data.ChatID, time.Duration(data.Hour)*time.Hour)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}
	if len(histories) <= 5 {
		var errMessage string

		switch data.RecapMode {
		case tgchat.AutoRecapSendModePublicly:
			errMessage = fmt.Sprintf("最近 %d 小时内暂时没有超过 5 条的聊天记录可以生成聊天回顾哦，要再多聊点之后再试试吗？", data.Hour)
		case tgchat.AutoRecapSendModeOnlyPrivateSubscriptions:
			errMessage = fmt.Sprintf("最近 %d 小时内暂时没有超过 5 条的聊天记录可以生成聊天回顾哦，要再等待群内成员多聊点之后再试试吗？", data.Hour)
		default:
			errMessage = fmt.Sprintf("最近 %d 小时内暂时没有超过 5 条的聊天记录可以生成聊天回顾哦，要再多聊点之后再试试吗？", data.Hour)
		}

		return nil, tgbot.
			NewMessageError(errMessage).
			WithReply(replyToMessage)
	}

	chatType := telegram.ChatType(c.Update.CallbackQuery.Message.Chat.Type)

	logID, summarizations, err := h.chatHistories.SummarizeChatHistories(data.ChatID, chatType, histories)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}

	counts, err := h.chatHistories.FindFeedbackRecapsReactionCountsForChatIDAndLogID(data.ChatID, logID)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}

	inlineKeyboardMarkup, err := h.chatHistories.NewVoteRecapInlineKeyboardMarkup(c.Bot, data.ChatID, logID, counts.UpVotes, counts.DownVotes, counts.Lmao)
	if err != nil {
		return nil, tgbot.
			NewExceptionError(err).WithMessage("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}

	summarizations = lo.Filter(summarizations, func(item string, _ int) bool { return item != "" })
	if len(summarizations) == 0 {
		return nil, tgbot.
			NewMessageError("聊天记录回顾生成失败，请稍后再试！").
			WithReply(replyToMessage)
	}

	for i, s := range summarizations {
		summarizations[i] = tgbot.ReplaceMarkdownTitlesToTelegramBoldElement(s)
	}

	summarizationBatches := tgbot.SplitMessagesAgainstLengthLimitIntoMessageGroups(summarizations)
	for i, s := range summarizationBatches {
		var content string
		if len(summarizationBatches) > 1 {
			content = fmt.Sprintf("%s\n\n(%d/%d)\n%s#recap\n<em>🤖️ Generated by chatGPT</em>",
				strings.Join(s, "\n\n"),
				i+1,
				len(summarizationBatches),
				lo.Ternary(chatType == telegram.ChatTypeGroup, "\n<b>Tips: </b>由于群组不是超级群组（supergroup），因此消息链接引用暂时被禁用了，如果希望使用该功能，请通过短时间内将群组开放为公共群组并还原回私有群组，或通过其他操作将本群组升级为超级群组后，该功能方可恢复正常运作。\n\n", ""),
			)
		} else {
			content = fmt.Sprintf("%s\n\n%s#recap\n<em>🤖️ Generated by chatGPT</em>",
				strings.Join(s, "\n\n"),
				lo.Ternary(chatType == telegram.ChatTypeGroup, "<b>Tips: </b>由于群组不是超级群组（supergroup），因此消息链接引用暂时被禁用了，如果希望使用该功能，请通过短时间内将群组开放为公共群组并还原回私有群组，或通过其他操作将本群组升级为超级群组后，该功能方可恢复正常运作。\n\n", ""),
			)
		}

		msg := tgbotapi.NewMessage(c.Update.CallbackQuery.Message.Chat.ID, content)
		msg.ParseMode = tgbotapi.ModeHTML
		msg.ReplyMarkup = inlineKeyboardMarkup

		if c.Update.CallbackQuery.Message.ReplyToMessage != nil {
			msg.ReplyToMessageID = c.Update.CallbackQuery.Message.ReplyToMessage.MessageID
		}

		h.logger.Info("sending chat histories recap for chat",
			zap.Int64("chat_id", c.Update.CallbackQuery.Message.Chat.ID),
			zap.String("text", msg.Text),
		)

		c.Bot.MaySend(msg)
	}

	return nil, nil
}
